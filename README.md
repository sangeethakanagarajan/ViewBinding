# ViewBinding

1. Once view binding is enabled in a module, it generates a binding class for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.
The name of the binding class is generated by converting the name of the XML file to camel case and adding the word "Binding" to the end.


2. To enable view binding in a module, set the **viewBinding** build option to **true** in the *module-level build.gradle* file

```
android {
    ...
    buildFeatures {
        viewBinding true
    }
}
```

3. If you want a layout file to be ignored while generating binding classes, add the **tools:viewBindingIgnore="true"** attribute to the root view of that layout file

```
<LinearLayout
        ...
        tools:viewBindingIgnore="true" >
    ...
</LinearLayout>
```

## Differences from findViewById

View binding has important advantages over using findViewById:

**Null safety**: Since view binding creates direct references to views, there's no risk of a null pointer exception due to an invalid view ID. Additionally, when a view is only present in some configurations of a layout, the field containing its reference in the binding class is marked with @Nullable.

**Type safety**: The fields in each binding class have types matching the views they reference in the XML file. This means that there's no risk of a class cast exception.

These differences mean that incompatibilities between your layout and your code will result in your build failing at compile time rather than at runtime.

[Refer Android Documentation link](https://developer.android.com/topic/libraries/view-binding)
